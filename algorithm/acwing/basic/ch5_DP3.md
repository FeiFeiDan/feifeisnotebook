# 区间 DP

状态表示的时候表示的是某一个区间

## 石子合并

### 题目描述

设有 **N** 堆石子排成一排，其编号为 **1**,**2**,**3**,**…**,**N**

每堆石子有一定的质量，可以用一个整数来描述，现在要将这 **N** 堆石子合并成为一堆。

每次只能合并相邻的两堆，合并的代价为这两堆石子的质量之和，合并后与这两堆石子相邻的石子将和新堆相邻，合并时由于选择的顺序不同，合并的总代价也不相同。

例如有 **4**4 堆石子分别为 `1 3 5 2`， 我们可以先合并 **1**、**2**堆，代价为 **4**，得到 `4 5 2`， 又合并 **1**、**2** 堆，代价为 **9**9，得到 `9 2` ，再合并得到 **11**11，总代价为 **4**+**9**+**11**=**24**；

如果第二步是先合并 **2**、**3** 堆，则代价为 **7**，得到 `4 7`，最后一次合并代价为 **11**11，总代价为 **4**+**7**+**11**=**22**。

问题是：找出一种合理的方法，使总的代价最小，输出最小代价。

#### 输入格式

第一行一个数 **N** 表示石子的堆数 **N**。

第二行 **N** 个数，表示每堆石子的质量(均不超过 **1000**)。

#### 输出格式

输出一个整数，表示最小代价。

#### 数据范围

**1**≤**N**≤**300**

#### 输入样例：

```
4
1 3 5 2
```

#### 输出样例：

```
22
```

### 分析

状态表示：

* 集合：$i,j$ 所有将第 $i$ 堆石到第 $j$ 堆石子的合并方式；
* 属性：所有合并方式里代价的最小值；

状态计算：

* 以最后一次分界线的位置来分类
  * 以 k 为分界线，首先合并$[i, k]$然后合并$[k+1,j]$，最后将这两个合并
  * $f(i,j) = \min (f(i,k) + f(k+1,j) + (s_j - s_{i-1}))$；（前缀和）

另外的一个难点是：循环怎么写

* 要确保计算这一个状态所使用的状态已经被算过了
  * 可以按照区间长度，由小到大来写，

### Code

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 310;

int s[N];
int f[N][N];

int main()
{
    int n;
    cin >> n;
  
    for (int i = 1; i <= n; i ++) cin >> s[i];
    for (int i = 1; i <= n; i ++) s[i] += s[i-1]; // 处理一下前缀和
  
    for (int len = 2; len <= n; len ++)
        for (int i = 1; i + len - 1 <= n ; i++)
        {
            int l = i, r = i + len - 1;
            f[l][r] = 1e9; // 需要先将其初始化成一个比较大的数
            for (int k = l; k < r; k ++)
                f[l][r] = min(f[l][r], f[l][k] + f[k+1][r] + s[r] - s[l-1]);
        }
    
    cout << f[1][n];
  
    return 0;
}
```
