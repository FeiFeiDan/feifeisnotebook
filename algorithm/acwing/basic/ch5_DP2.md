# 线性DP

## 数字三角形

### 题目描述

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数 **n**，表示数字三角形的层数。

接下来 **n** 行，每行包含若干整数，其中第 **i** 行表示数字三角形第 **i** 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

**1**≤**n**≤**500**
−**10000**≤三角形中的整数**≤**10000−10000≤三角形中的整数≤10000

#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```

### Solution

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510;

// 状态表示：f[i][j] 如果加到第i行第j个数了，那么所有加法的最大值是多少
// 状态计算：f[i][j] = max( f[i-1][j], f[i-1][j-1] )
// 要注意：左上和右上不能越界

int s[N][N];
int f[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= i; j ++)
            cin >> s[i][j];
  
    for (int i = 1; i <= n; i ++)
        for (int j = i; j >= 1; j --)
        {
            if (i == j) f[j] = f[j-1] + s[i][j]; // 注意右上不要越界
            else if (j > 1) f[j] = max(f[j], f[j-1]) + s[i][j];
            else f[j] += s[i][j]; // 注意左上不要越界
        }
  
    int ans = f[1];
    for (int i = 1; i <= n; i ++)
        ans = max(ans, f[i]);
  
    cout << ans;
  
    return 0;
}
```

其实这道题如果不想处理边界的话，可以把所有的 `f[N]` 设为负无穷

## 最长递增子序列

### 题目描述

给定一个长度为 **N** 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 **N**。

第二行包含 **N** 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

**1**≤**N**≤**1000**，
−**10**9**≤**数列中的数**≤**10**9**−109≤数列中的数≤109

#### 输入样例：

```
7
3 1 2 1 8 5 6
```

#### 输出样例：

```
4
```

### Solution

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

// 状态表示
// f[i]:以第i个元素的值为最大值的最长递增子序列的长度
// f[i-1]:以第i-1个元素为最大值的最长递增子序列的长度

// 状态计算
// if s[i] > s[k], (k < i), f[i] = f[k+1]

int s[N], f[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++) cin >> s[i];
  
    s[0] = -1e9-1; // 也可以不这样写，而是把所有的 f[i] 都先初始化为 1
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j < i; j ++)
        {
            if (s[j] < s[i]) f[i] = max(f[i], f[j] + 1);
        }
  
    int ans = 0;
    for (int i = 1; i <= n; i ++)
        ans = max(ans, f[i]);
  
    cout << ans;
  
    return 0;
}
```

## 最长递增子序列 II （对朴素算法的优化）

首先来观察一下这个序列 `3 1 2 1 8 5 6`，我们可以观察到对于递增子序列而言，8 能接在 1 的后面，8 一定也能接在 3 的后面，因为 1 比 3 小，所以就不用再判断一次 8 能不能接在 3 后面了。

按照这个原则我们就可以进行推广：长度为 1 的最小子序列，我们存结尾最小的一个的就可以了，长度为 2 的最小子序列，我们也存长度最小的一个就可以了。

然后呢，不同长度的递增子序列，他们结尾的最小元素，一定是随着子序列长度的增加而递增的。（可以用反证法证明）

然后，如何求得，以某个元素结尾的，最长递增子序列（应该接在哪个以最小元素结尾的递增子序列的后面）：二分

这里设$Q_4$是所有长度为 4 的序列中，结尾元素最小的那个序列。

假设，在二分查找中，$S_i$的比$Q_4$的最后一个元素大，比$Q_5$的最后一个元素小。那么$S_i$一定是接在$Q_4$的后面，然后，将 $Q_5$的最后一个元素更新为$S_i$；

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 100010;

int n;
int a[N], q[N]; // a[N]用来存放数，q[N]用来存放每个长度的递增子序列结尾的最小值是什么

int main()
{
    cin >> n;
    for (int i = 0; i < n; i ++) cin >> a[i];
  
    int len = 0;
    q[0] = -2e9;
    for (int i = 0; i < n; i ++)
    {
        int l = 0, r = len;
        while (l < r)
        {
            int mid = l + r + 1 >> 1;
            if (q[mid] < a[i]) l = mid;
            else r = mid - 1;
        }
        len = max(len, r + 1);
        q[r + 1] = a[i];
    }
  
    cout << len;
  
    return 0;
}
```

## 最长公共子序列

### 题目描述

给定两个长度分别为 **N**和 **M** 的字符串 **A** 和 **B**，求既是 **A** 的子序列又是 **B**的子序列的字符串长度最长是多少。

#### 输入格式

第一行包含两个整数 **N**和 **M**。

第二行包含一个长度为 **N**的字符串，表示字符串 **A**。

第三行包含一个长度为 **M**的字符串，表示字符串 **B**。

字符串均由小写字母构成。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

**1**≤**N**,**M**≤**1000**

#### 输入样例：

```
4 5
acbd
abedc
```

#### 输出样例：

```
3
```

### Solution

状态表示：$f(i, j)$ 表示两个序列分别取前 $i$ $j$ 个元素，这时最大最长子序列的长度

状态计算：几种情况

* 一定包含第 $i$ $j$ 个元素，这种状态可以表示为 $f(i-1, j-1) + 1$.
* 一定不包含第 $i\,j$个元素，这种状态可以表示为 $f(i-1, j-1)$.
* 包含第$i$个元素但是不包含第$j$个元素（或相反），这时候很难去表示，因为如果表示成$f(i-1, j)$的话，其实是无法表示必须包含 j 的
  * 但是这又是可以接受的，因为虽然有重复，但是求最大值的这个情况是可以有重复的
* 所以状态表示就可以表示为：$f(i, j) = \text{max}(f(i, j), f(i-1, j), f(i, j-1))$.

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

string A, B;
int f[N][N];

int main()
{
    int n, m;
    cin >> n >> m;
    cin >> A >> B;
  
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
        {
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if (A[i-1] == B[j-1]) f[i][j] = max(f[i-1][j-1] + 1, f[i][j]);
        }
  
    cout << f[n][m];
  
    return 0;
}
```

## 最短编辑距离

### 题目描述

给定两个字符串 **A** 和 **B**，现在要将 **A** 经过若干操作变为 **B**，可进行的操作有：

1. 删除–将字符串 **A** 中的某个字符删除。
2. 插入–在字符串 **A** 的某个位置插入某个字符。
3. 替换–将字符串 **A** 中的某个字符替换为另一个字符。

现在请你求出，将 **A** 变为 **B** 至少需要进行多少次操作。

#### 输入格式

第一行包含整数 **n**，表示字符串 **A** 的长度。

第二行包含一个长度为 **n** 的字符串 **A**。

第三行包含整数 **m**，表示字符串 **B** 的长度。

第四行包含一个长度为 **m** 的字符串 **B**。

字符串中均只包含大小写字母。

#### 输出格式

输出一个整数，表示最少操作次数。

#### 数据范围

**1**≤**n**,**m**≤**1000**

#### 输入样例：

```
10
AGTCTGACGC
11
AGTAAGTAGGC
```

#### 输出样例：

```
4
```

### 分析

首先，需要处理两个字符串，所以经验上这应该是一个二维的动态规划（一个字符串算一维）

然后，想想看怎么状态表示：

状态表示：

* 集合：$(i,j)$就表示对于字符串 $a(1,i)$（表示取字符串 a 从 1 取到 i ）变换成$b(1,j)$的所有可行的操作
* 那么属性就很简单了，就是单纯的最小值

那么怎么进行状态计算呢？为了进行状态计算，首先要进行状态划分。经验上，我们总是以最后一个元素为分界点。那么这里，我们也以 $a(1,i)$变换为$b(i,j)$时，最后一个字符的操作，来进行状态划分。

这样进行状态划分还有一个考量，假设从 a 到 b 一共有 n 步操作，但其实这 n 步操作是可以打乱的，所以，在想转移方程式，我们盯着 a 的最后一位字符就可以了。

那么最后一位字符的操作，有四种方式：增、删、改，还有就是不动。

当我要增加一位时，我增加的是最后一位。增加完之后，a 与 b 是相等的。那么在 a 中增加的那个字符就一定是 `b[j]`。那么 `a[i]` 和 `b[j-1]` 就一定是相等的。

如果我要删除 a 的最后一位的话，说明 a 的最后一位是多余的。a 删除最后一位转换成为 b 就可以表示为：`f[i-1][j] + 1`。（+1就是把最后一位删掉）

如果是修改 a 的最后一位的话，说明 `a[i-1]` 和 `b[j-1]` 是匹配的。那么状态转移方程就可以写为 `f[i-1][j-1] + 1`。

最后一种情况就是最后一位不需要改，那么状态转移方程就是 `f[i-1][j-1]`。

所以，状态计算的代码就可以写为

```c++
for (int i = 1; i <= n; i ++)
    for (int j = 1; j <= m; j ++)
    {
        f[i][j] = min(f[i-1][j], f[i][j-1]) + 1;
        if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i-1][j-1] + 1);
	else f[i][j] = min(f[i][j], f[i-1][j-1]);
    }
```

然后观察一下这个循环中会用到什么初始条件，当 `i == 0` 时，循环会用到 `f[0][j]`，其代表的意思是，一个长度为 0 的字符串，变换成一个长度为 j 的字符串需要多少步操作。很显然需要 j 步操作。可是 `f[0][j]` 却被初始化为了 0。所以需要重新初始化。

```c++
for (int i = 0; i <= m; i ++) f[0][i] = i;
for (int i = 0; i <= n; i ++) f[i][0] = i;
```

### Code

完整的代码为：

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
string a, b;
int f[N][N];

int main()
{
    cin >> n >> a >> m >> b;
  
    a = ' ' + a; // 因为后面比较时，默认字符串是从 1 开始的
    b = ' ' + b;
  
    // 首先初始化一下，边界条件
    // 当第一个字符串为空的时候，其只能通过添加 i 个元素变成和第二个字符串相等
    for (int j = 0; j <= m; j ++) f[0][j] = j;
    // 当第二个字符串为空的时候，第一个字符串也只能通过删减元素来与第二个字符串个相等
    for (int i = 0; i <= n; i ++) f[i][0] = i;
  
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
        {
            f[i][j] = min(f[i-1][j], f[i][j-1]) + 1;
            if (a[i] == b[j]) f[i][j] = min(f[i][j], f[i-1][j-1]);
            else f[i][j] = min(f[i][j], f[i-1][j-1] + 1);
        }
  
    cout << f[n][m];
  
    return 0;
}
```

nihao
