# 线性DP

## 数字三角形

### 题目描述

给定一个如下图所示的数字三角形，从顶部出发，在每一结点可以选择移动至其左下方的结点或移动至其右下方的结点，一直走到底层，要求找出一条路径，使路径上的数字的和最大。

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

#### 输入格式

第一行包含整数 **n**，表示数字三角形的层数。

接下来 **n** 行，每行包含若干整数，其中第 **i** 行表示数字三角形第 **i** 层包含的整数。

#### 输出格式

输出一个整数，表示最大的路径数字和。

#### 数据范围

**1**≤**n**≤**500**
−**10000**≤三角形中的整数**≤**10000−10000≤三角形中的整数≤10000

#### 输入样例：

```
5
7
3 8
8 1 0 
2 7 4 4
4 5 2 6 5
```

#### 输出样例：

```
30
```

### Solution

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 510;

// 状态表示：f[i][j] 如果加到第i行第j个数了，那么所有加法的最大值是多少
// 状态计算：f[i][j] = max( f[i-1][j], f[i-1][j-1] )
// 要注意：左上和右上不能越界

int s[N][N];
int f[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= i; j ++)
            cin >> s[i][j];
    
    for (int i = 1; i <= n; i ++)
        for (int j = i; j >= 1; j --)
        {
            if (i == j) f[j] = f[j-1] + s[i][j]; // 注意右上不要越界
            else if (j > 1) f[j] = max(f[j], f[j-1]) + s[i][j];
            else f[j] += s[i][j]; // 注意左上不要越界
        }
    
    int ans = f[1];
    for (int i = 1; i <= n; i ++)
        ans = max(ans, f[i]);
  
    cout << ans;
  
    return 0;
}
```

其实这道题如果不想处理边界的话，可以把所有的 `f[N]` 设为负无穷

## 最长递增子序列

### 题目描述

给定一个长度为 **N** 的数列，求数值严格单调递增的子序列的长度最长是多少。

#### 输入格式

第一行包含整数 **N**。

第二行包含 **N** 个整数，表示完整序列。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

**1**≤**N**≤**1000**，
−**10**9**≤**数列中的数**≤**10**9**−109≤数列中的数≤109

#### 输入样例：

```
7
3 1 2 1 8 5 6
```

#### 输出样例：

```
4
```

### Solution

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

// 状态表示
// f[i]:以第i个元素的值为最大值的最长递增子序列的长度
// f[i-1]:以第i-1个元素为最大值的最长递增子序列的长度

// 状态计算
// if s[i] > s[k], (k < i), f[i] = f[k+1]

int s[N], f[N];

int main()
{
    int n;
    cin >> n;
    for (int i = 1; i <= n; i ++) cin >> s[i];
  
    s[0] = -1e9-1; // 也可以不这样写，而是把所有的 f[i] 都先初始化为 1
    for (int i = 1; i <= n; i ++)
        for (int j = 0; j < i; j ++)
        {
            if (s[j] < s[i]) f[i] = max(f[i], f[j] + 1);
        }
  
    int ans = 0;
    for (int i = 1; i <= n; i ++)
        ans = max(ans, f[i]);
  
    cout << ans;
  
    return 0;
}
```

## 最长公共子序列

### 题目描述

给定两个长度分别为 **N**和 **M** 的字符串 **A** 和 **B**，求既是 **A** 的子序列又是 **B**的子序列的字符串长度最长是多少。

#### 输入格式

第一行包含两个整数 **N**和 **M**。

第二行包含一个长度为 **N**的字符串，表示字符串 **A**。

第三行包含一个长度为 **M**的字符串，表示字符串 **B**。

字符串均由小写字母构成。

#### 输出格式

输出一个整数，表示最大长度。

#### 数据范围

**1**≤**N**,**M**≤**1000**≤1000

#### 输入样例：

```
4 5
acbd
abedc
```

#### 输出样例：

```
3
```

### Solution

状态表示：$f(i, j)$ 表示两个序列分别取前 $i$ $j$ 个元素，这时最大最长子序列的长度

状态计算：几种情况

* 一定包含第 $i$ $j$ 个元素，这种状态可以表示为 $f(i-1, j-1) + 1$.
* 一定不包含第 $i\,j$个元素，这种状态可以表示为 $f(i-1, j-1)$.
* 包含第$i$个元素但是不包含第$j$个元素（或相反），这时候很难去表示，因为如果表示成$f(i-1, j)$的话，其实是无法表示必须包含 j 的
  * 但是这又是可以接受的，因为虽然有重复，但是求最大值的这个情况是可以有重复的
* 所以状态表示就可以表示为：$f(i, j) = \text{max}(f(i, j), f(i-1, j), f(i, j-1))$.

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

string A, B;
int f[N][N];

int main()
{
    int n, m;
    cin >> n >> m;
    cin >> A >> B;
  
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
        {
            f[i][j] = max(f[i-1][j], f[i][j-1]);
            if (A[i-1] == B[j-1]) f[i][j] = max(f[i-1][j-1] + 1, f[i][j]);
        }
  
    cout << f[n][m];
  
    return 0;
}
```
