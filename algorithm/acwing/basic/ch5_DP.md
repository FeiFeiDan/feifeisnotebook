# 动态规划

## 模型 1：背包问题

### 背包问题的分类

**背包问题总揽：**背包问题指的是我有一个体积有限的背包，体积为$V$。有一些物品体积为$v_i$，价值为$w_i$。我想用这些背包装下价值尽可能多的物品。

**0-1背包问题：**每一件物品只能用一次

**完全背包问题：**每一件物品能用无数次

**多重背包问题：**每个物品的数量不一样，每个物品只有$s_i$个。（会结合这个问题讲多重背包问题的经典优化方式）

**分组背包问题：**物品有$n$组，每一组物品里有若干个，每一组里面最多只能选一个物品，（他是互斥的）

不一定要装满背包

### 背包问题的解决思路（动态规划）

DP

* 状态表示：思考一下这个问题需要用几维的状态来表示，背包问题的话一般是两维$f(i,j)$
  * 集合：DP 问题的每一个状态都表示的是一个集合，我们需要考虑$f(i, j)$表示的是哪一个集合。背包问题的话就是所有选法的一个集合。
    * 集合是一堆的选法，是所有选法的一个集合。
    * 选法的话要满足两个条件：
      * 1，只从前$i$个物品当中选
      * 2，选出来的物品的最体积$\leq j$
  * 属性：（$f(i,j)$是集合的某种属性，$(i, j)$代表的是一种集合，但是$f(i,j)$存的是一个数，这个数其实是这个集合的某种属性）属性的话一般有三种：最大值（比如说最大价值）、最小值（比如说最小代价）、数量。背包问题里的属性应该是最大值。
* 状态计算：把每一个状态$f(i,j)$算出来
  * 考虑一下$f(i, j)$可以怎么计算出来，如果我们把所有情况计算出来之后那我们就能得到$f(N, V)$，这个集合代表的就是在前$N$个的物品里选，体积不超过$V$的情况下，价值的最大值。
  * 状态计算就是集合的划分：状态计算要考虑的是，如何把我们当前的集合划分成更小的子集，使得每一个子集我们都可以算出来，都可以用前面更小的状态表示出来
  * 背包问题的话，我们可以把$f(i,j)$这个选法表示成两大类，一类是不含$i$，另一类是含$i$的。
    * 子集划分的两个原则，1、不重复，不漏。不漏是一定要满足的，不重复的话，不一定是所有情况下都要满足。（求最大值的话，重复也无所谓，求个数的话就要不重复）
  * 如何表示这两个子集
    * 不含$i$：从$1 \sim i$中，并且不含$i$，并且我的总体积不超过$j$，这样选法的一个集合。
      * 将这三个条件合并一下便是从$1 \sim \text{i - 1}$中选，并且体积不超过$j$
      * 所以这个集合就可以表示为 $f(i-1, j)$
    * 含$i$情况：从$ 1\sim i$中选，体积不超过$j$，并且还要包换$i$，这样选法的一个集合，但是这样的一个集合很难去表示
      * 因为我们所有算法都包含第$i$个物品，所以我们把每种选法中的第$i$个物品都去掉，这并不影响最大值，因为所有选法都包含第$i$个物品的重量$w_i$，同样的，每种选法也都包含第$i$个物品的体积$w_i$
      * 所以，这种选法就可以这样表示从$1 \sim i-1$个物品里选，体积不能大于$j-v_i$的所有选法的集合，也就是找$f(i-1,j-v_i)$下的最大值
      * 然后再加上第$i$个物品的价值$w_i$，就能找到包含第$i$个物体的最大值。$f(i-1,j-v_i)+w_i$
* 优化：DP 问题的优化一般动态规划的算法或是动态规划的方程做一个等价变形（所以来说一开始不做优化，写好了再做优化）

## 0-1背包问题

### Description

有 **N** 件物品和一个容量是 **V** 的背包。每件物品只能使用一次。

第 **i** 件物品的体积是 **v**i，价值是 **w**i。

求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。
输出最大价值。

#### 输入格式

第一行两个整数，**N**，**V**，用空格隔开，分别表示物品数量和背包容积。

接下来有 **N** 行，每行两个整数 **v**i,**w**i，用空格隔开，分别表示第 **i** 件物品的体积和价值。

#### 输出格式

输出一个整数，表示最大价值。

#### 数据范围

**0**<**N**,**V**≤**1000**
0**<**v**i,**w**i≤1000

### Solution

#### 二维的写法

`'n'` 代代表物体的数量，`'m'` 代表背包的体积。

首先从 `f[1][1]` 开始，`f[0][1]` 的值是 0，`'j'` 的值为 1，如果 `v[i]` 的值大于 1 的话，背包就放不下了，所以 `f[1][1]` 的值就是 0.

    但是注意里面的那个循环，`for (int j = 1; j <= m; j ++)` ，这个循环就会一直试，当背包的体积为 `'j'` 时，这个物体放的下吗？

    `f[1][j] = f[0][j] = 0`，然后比较 `v[1]` 和 `'j'` 的大小，如果放得下的话，`f[1][j]` 的值就等于  `w[1]`。

    这也是说的通的，因为这个时候就只取前 1 个物体嘛，所以只要放得下，那么此时的最大值就一定是`w[1]`

紧接着，当 `i == 2` 的时候，就是要找 `f[2][j]`（取前 2 个物体，在背包体积为 `'j'` 的情况下，背包能包含的最大价值是多少），为了找到 `f[2][j]` 的值，我需要找到 `f[1][j]` 的值和 `f[1][j - v[2]]` 的值，而这两个值，已经被算出来了。

然后呢，命运的齿轮就开始转动起来了。

最后将 `f[m][n]` 的值返回就好了。

所以呢，其实这道题一个非常重要的点是初始化，也就是说，我在计算 `f[1][j]` 的值的时候，需要知道 `f[0][j]` 的值，而 `f[0][j]` 的值理所应当的是 0（取前 0 个物品嘛，那价值肯定是 0）。而由于 c++ 的特性，`f[0][j]` 的值已经被初始化好了。

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];

int f[N][N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) cin >> v[i] >> w[i]; // 因为数组本来就开的比较大，所以这样写是不会溢出的
  
    // 首先初始化，但是因为 f[N][N]是定义在外面的，所以就已经初始化为 0 了
  
    for (int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
        {
            f[i][j] = f[i - 1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i - 1][j - v[i]] + w[i]);
        }
  
    cout << f[n][m] << endl;
  
    return 0;
}
```

#### 一维的写法

然后看如何能优化，我们就会注意到对于 `f[i]` 来说，它其实只用到了 `f[i-1]`，其他都没有用到，所以说这里可以用**滚动数组**来做。

而 `f[j]` 不管是 `'j'` 还是 `j - v[i]` ，它都是小于等于 `'j'` 的。

所以，我们可以把 `f[i]` 这个维度删去，然后这样来写这个代码。（滚动数组）

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
  
    for (int i = 1; i <= n; i ++)
        for (int j = m; j >= v[i]; j --)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
      
    cout << f[m];
  
    return 0;
}
```

## 完全背包问题

### Description

### Solution

动态规划

* 状态表示 `f[i][j]`
  * 集合：只考虑前去前 `'i'` 个元素，在体积容量不超过 `'j'` 的情况下，所有的选法
  * 属性 `f[i][j]`：只考虑前去前 `'i'` 个元素，在体积容量不超过 `'j'` 的情况下，所有的选法中，价值的最大值
* 状态计算（集合划分）
  * 在 0-1 背包问题时，我们是通过第 i 个物品是选 0 个还是选 1 个分成了两组
  * 这里，我们可以根据第 i 个物品选多少个分，分成若干组（第 i 个物品选 0 个，第 i 个物品选 1 个，第 i 个物品选 2 个 ……）
  * 然后看一下每一个子集它的值应该是多少
  * 第一个子集很好算，相当于是第 i 个物品不选，等价于只考虑前 i-1 个物品
  * 对于其他的情况，不妨设第 i 个物品选了 k 个
    * 就相当于选不含 k 个第 i 个物品，然后在体积不超过 `j-k * v[i]` 的情况下，背包能装下价值的最大值，然后再将 `k * w[i]`加回来

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int m, n;

int v[N], w[N];
int f[N][N];

int main()
{
    // 这个代码在 N=1000的时候会超时，当 N=1000 的时候，这个代码要执行 10^9 步
    cin >> m >> n;
    for (int i = 1; i <= m; i ++) cin >> v[i] >> w[i];
  
    for (int i = 1; i <= m; i ++)
        for (int j = 1; j <= n; j ++)
        {
            f[i][j] = f[i-1][j];
            for (int k = 1; k <= j/v[i]; k ++)
                f[i][j] = max(f[i][j], f[i-1][j - v[i] * k] + w[i] * k);
        }
  
    cout << f[m][n];
  
    return 0;
}
```

### 优化方式

假设第 i 个物体的体积是 v，重量是 w，观察这个状态转移方程 $f(i, j)=max(f(i-1,j), f(i-1, j-kv)+kw)$，将其展开

$f(i,j) = max(f(i-1,j), f(i-1, j-v) + w, f(i-1, j-2v)+2w, f(i-1,j-3v)+3w, ...)$，

与 $f(i, j-v)$相比较

$f(i,j-v)\\=max(f(i-1, j-v), f(i-1, j-v-v) + w, f(i-1,j-v-2v) + 2w, f(i-1,j-v-3v) + 3w, ...)\\=max(f(i-1,j-v), f(i-1,j-2v) + w, f(i-1, j-3v)+2w, ...)\\=max(f(i-1,j-v)+w, f(i-1,j-2v)+2w, f(i-1,j-3v)+3w, ...)-w$

$f(i,j) = max(f(i-1,j), f(i,j-v)+w)$

所以，我们的代码就可以优化为

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int m, n;

int v[N], w[N];
int f[N][N];

int main()
{
    cin >> m >> n;
    for (int i = 1; i <= m; i ++) cin >> v[i] >> w[i];
  
    for (int i = 1; i <= m; i ++)
        for (int j = 1; j <= n; j ++)
        {
            f[i][j] = f[i-1][j];
            if (j >= v[i]) f[i][j] = max(f[i][j], f[i][j-v[i]]+w[i]);
        }
  
    cout << f[m][n];
  
    return 0;
}
```

#### 使用滚动数组优化为 1 维的

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;

int v[N], w[N];
int f[N];

int main()
{
    cin >> n >> m;
    for (int i = 1; i <= n; i ++) cin >> v[i] >> w[i];
  
    for (int i = 1; i <= n; i ++)
        for (int j = v[i]; j <= m; j ++)
            f[j] = max(f[j], f[j-v[i]]+w[i]);
    
    cout << f[m];
  
    return 0;
}
```

## 多重背包问题

多重背包问题跟前两个问题的区别是，一个物体不是要么只有 1 件，要么有无穷件，而是有确定的件数 $s_i$ 件

动态规划

* 状态表示
  * $(i,j)$表示取前 i 个物体，在体积不超过 j 的的情况下的所有取法
  * $f(i,j)$表示取前 i 个物体，在体积不超过 j 的的情况下所有取法下背包能装下价值的最大值
* 状态计算
  * $f(i, j)$可以拆分为，$f(i-1, j)$和 $\text{max}_{k=1}^{s} (f(i-1, j-kv)+kw)$之间的最大值

所以，先写二维的写法（无优化）

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 1010;

int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main()
{
    cin >> n >> m;
    for(int i = 1; i <= n; i ++) cin >> v[i] >> w[i] >> s[i];
  
    for(int i = 1; i <= n; i ++)
        for (int j = 1; j <= m; j ++)
        {
            f[i][j] = f[i-1][j];
            for (int k = 1; k <= s[i]; k ++)
                if(j >= k*v[i]) f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + k*w[i]);
        }
  
    cout << f[n][m];
  
    return 0;
}
```

### 优化方法（二进制优化）

首先写出状态转移方程

$$
\begin{align} &f(i,j)\\&=max(f(i-1, j), f(i-1, j-v)+w, f(i-1, j-2v)+2w, f(i-1, j-3v)+3w, ..., f(i-1, j-sv)+sw\ \ \ \ \ \ \ \ \ \,)\\&f(i, j-v)\\&=max(\qquad\qquad\,,f(i-1,j-v),\quad\ \ \ \ \,f(i-1,j-2v)+w,\ \ f(i-1, j-3v)+2w,...,f(i-1,j-sv)+(s-1)w，f(i-1,j-(s+1)v)+sw)\end{align}
$$

这里不方便的是，观察$f(i,j-v)$的$\text{max}$中多出了一项$f(i-1,j-(s+1)v)+sw$，而 max 是不能做减法的，也就是说，假如说我知道 $s_1$到$s_i$的最大值，就算我们知道 $s_i$的值，也没有办法知道$s_1$到$s_{i-1}$的最大值

但是我们可以用一种二进制的优化方式，我们可以通过二进制，把第 i 个物品的所有 s 个取法做一个拆分

以 200 为例，200可以拆解成 1，2，4，8，16，32，64，73 的和。所以说 $[0, 200-73]$ 内所有的数都能被 $\{ 1,2,4,8,16,32,64 \}$ 表示出来。而如果想表示$(200-73,200]$内的数的话，只需要让能表示的数加上一个 73就可以了。（二进制优化）

然后，就能把多重背包问题转换成 0-1背包问题了

```c++
#include <iostream>
#include <algorithm>

using namespace std;

const int N = 11010, M = 2010;
int v[N], w[N]; // 不需要写 s[N] 因为会将其不同的取法转换成一件不同的物品
int f[M];

int main()
{
    int n, m;
    cin >> n >> m;
  
    int cnt = 0;
    for (int i = 1; i <= n; i ++)
    {
        int a, b, s;
        cin >> a >> b >> s;
        int k = 1; // 存放幂次
        while (k <= s)
        {
            cnt ++;
            v[cnt] = a * k;
            w[cnt] = b * k;
            s -= k;
            k *= 2;
        }
        if (s > 0)
        {
            cnt ++;
            v[cnt] = a*s;
            w[cnt] = b*s;
        }
    }
    for (int i = 1; i <= cnt; i ++)
        for (int j = m; j >= v[i]; j --)
            f[j] = max(f[j], f[j - v[i]] + w[i]);
        
    cout << f[m];
  
    return 0;
}
```
